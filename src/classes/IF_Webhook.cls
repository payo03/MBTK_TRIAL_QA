/**
* @Author            : payo03@solomontech.net
* @Description 		 : 
* @Target            : 
* @Modification Log
  Ver      Date            Author                           Modification
  ===================================================================================
  1.0      2024-12-19      payo03@solomontech.net           Created
  1.1      2024-12-26      payo03@solomontech.net           Webhook ë¶„ê¸°ì²˜ë¦¬
  1.2      2025-02-05      payo03@solomontech.net           ëª¨ë‘ì‹¸ì¸. ëª¨ë“ ê³ ê° ì„œëª…ì™„ë£Œì‹œ ìƒíƒœê°’ ë¶„ê¸° ì¶”ê°€
  1.3      2025-02-26      payo03@solomontech.net           ëª¨ë‘ì‹¸ì¸. í›„ì²˜ë¦¬ Process ë¹„ë™ê¸°ë¡œ ì‹¤í–‰
  1.4      2025-04-17      payo03@solomontech.net           ëª¨ë‘ì‹¸ì¸, ì¹´ì¹´ì˜¤í†¡ í›„ì²˜ë¦¬ Process ìƒì†Class êµ¬í˜„
  1.5      2025-05-09      payo03@solomontech.net           Completed(Customer) ìƒíƒœì¡°ê±´ ë³€ê²½. ìµœì¢…ì„œëª…ì -> metadata í™•ì¸
*/
@RestResource(UrlMapping='/api/webhook/*')
global without sharing class IF_Webhook {

    global final static String LABEL_AUTHCODE = Label.ModuSignAuthcode;
    global final static String DOC_IF_ID = 'MDSIGN_006';

    @HttpPost
    global static void doPost() {
        // ver1.1 Webhook ë¶„ê¸°ì²˜ë¦¬
        String pathCase = RestContext.request.requestURI.substringAfter('/api/webhook/');
        System.debug(pathCase);
        switch on pathCase {
            // ëª¨ë‘ì‹¸ì¸ WebHook
            when 'modusign' { moduSignWebhook(); }
            // ì¹´ì¹´ì˜¤í†¡ WebHook
            when 'kakao' { kakaoWebhook(); }
        }
    }

    private static void moduSignWebhook() {
        String status;
        Datetime responseTime;
        Datetime requestTime = Datetime.now();

        String authcode;
        RestRequest request = RestContext.request;
        RestResponse response = RestContext.response;

        String requestBody = request.requestBody.toString();
        System.debug(requestBody);
        response.addHeader('Content-Type', 'application/json');
        try {
            /*
                https://developers.modusign.co.kr/docs/webhook-event
                ğŸ“˜ ì•„ë˜ì™€ ê°™ì€ ìƒí™©ì—ì„œ Webhookì€ í˜¸ì¶œ ì‹¤íŒ¨ë¡œ íŒë‹¨í•˜ê³  ìµœëŒ€ 5íšŒ ì¬ì‹œë„ í•©ë‹ˆë‹¤.

                    Webhook event ìˆ˜ì‹  ì‹œ 200ë²ˆëŒ€ ì‘ë‹µì´ ì•„ë‹ ê²½ìš° ì¬ì‹œë„í•©ë‹ˆë‹¤.
                    ì‘ë‹µì„(200ë²ˆëŒ€ ì‘ë‹µ) ë¨¼ì € íšŒì‹  í›„ ë‚´ë¶€ ì‘ì—…ì„ ì§„í–‰í•´ì£¼ì‹œëŠ” ê²ƒì„ ê¶Œì¥ ë“œë¦½ë‹ˆë‹¤.

                    ğŸ“Œ ë‹¤ìŒì˜ ê²½ìš° Webhook ìš”ì²­ ì‹¤íŒ¨ë¡œ ê°„ì£¼í•©ë‹ˆë‹¤.
                        - 2xx ì‘ë‹µì´ ì•„ë‹Œê²½ìš°
                        - ì‘ë‹µì— 10ì´ˆ ì´ìƒ ì†Œìš”ë˜ëŠ” ê²½ìš°(timeout)
                    ğŸ“Œ ìš”ì²­ ì‹¤íŒ¨ë¡œ ê°„ì£¼ëœ ê²½ìš°, ì‹¤íŒ¨ ì²˜ë¦¬ ì •ì±…ì— ë”°ë¼, Webhook ìµœëŒ€ 5íšŒ ìš”ì²­ì´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

                    â—ï¸ì •ìƒ ì²˜ë¦¬ê°€ ë˜ì—ˆìŒì—ë„ 2xxë¡œ ì‘ë‹µí•˜ì§€ ì•ŠëŠ” ê²½ìš°, Webhookì´ ì¬ì „ì†¡ë˜ë©° ì¤‘ë³µìœ¼ë¡œ ì²˜ë¦¬ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
                    â—ï¸ï¸ì´ì  ì–‘ì§€í•˜ì…”ì„œ ì˜¬ë°”ë¥¸ ì‘ë‹µì„ íšŒì‹ í•œ í›„ ë‹¤ìŒ ì‘ì—…ì„ ìˆ˜í–‰í•˜ë„ë¡ êµ¬í˜„í•˜ì‹œëŠ” ê²ƒì„ ê¶Œì¥í•´ ë“œë¦½ë‹ˆë‹¤.

                    ğŸ“Œ ì•„ë˜ì˜ ê²½ìš°ëŠ” ì¬ì‹œë„ í–ˆì„ ë•Œ ì„±ê³µ ì „í™œìœ¨ì´ ë‚®ê±°ë‚˜, ì˜ë„í•˜ì§€ ì•Šì€ ì¤‘ë³µ ì‘ì—…ì„ ë°œìƒì‹œí‚¬ ê°€ëŠ¥ì„± ìˆìœ¼ë¯€ë¡œ ì¬ì‹œë„ í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
                        - 401, 404 ì‘ë‹µì„ ë°˜í™˜í™˜ ê²½ìš°
                        - ì‘ë‹µì— 10ì´ˆ ì´ìƒì´ ì†Œìš”ë˜ëŠ” ê²½ìš°(timeout)
             */
            for(String key : request.headers.keySet()) {
                if('AUTHCODE'.equals(key.toUpperCase())) authcode = request.headers.get(key);
            }
            if(authcode == null || !('Bearer ' + LABEL_AUTHCODE).equals(authcode)) throw new IllegalArgumentException('Invalid Authcode: ' + authcode);

            IF_DTO.ModuSign moduSign = (IF_DTO.ModuSign) JSON.deserialize(requestBody, IF_DTO.ModuSign.class);
            String eventType = moduSign.event.type;
            String documentId = moduSign.document.id;
            String responseMessage = 'Webhook Receive Success. Event Type: ' + eventType;

            response.responseBody = Blob.valueOf(JSON.serialize(responseMessage));
            response.statusCode = 200;
            status = 'SUCCESS';
            responseTime = Datetime.now();

            // ver1.3 ëª¨ë‘ì‹¸ì¸. í›„ì²˜ë¦¬ Process ë¹„ë™ê¸°ë¡œ ì‹¤í–‰
            asyncAfterProcess(eventType, documentId);
        } catch(IllegalArgumentException e) {
            status = 'ERROR';
            responseTime = Datetime.now();

            response.responseBody = Blob.valueOf(JSON.serialize(e.getMessage()));
            response.statusCode = 401;
        } catch(Exception e) {
            status = 'ERROR';
            responseTime = Datetime.now();

            response.responseBody = Blob.valueOf(JSON.serialize(e.getMessage()));
            response.statusCode = 500;
        } finally {
            IF_DTO.LogWrapper objLogWrapper = new IF_DTO.LogWrapper();

            objLogWrapper.requestTime = requestTime;
            objLogWrapper.requestBody = requestBody;
            objLogWrapper.status = status;
            objLogWrapper.responseTime = responseTime;
            objLogWrapper.responseBody = response.responseBody.toString();
            objLogWrapper.errorCode = String.valueOf(response.statusCode);
            objLogWrapper.logType = IF_DTO.LOG_TYPE.MODUSIGN_IN;

            CommonUtilCustomController.setLog(objLogWrapper);
        }
    }

    private static void kakaoWebhook() {
        String status;
        Datetime responseTime;
        Datetime requestTime = Datetime.now();

        RestRequest request = RestContext.request;
        RestResponse response = RestContext.response;

        response.addHeader('Content-Type', 'application/json');
        String requestBody = request.requestBody.toString();
        try {
            String responseMessage = 'Webhook Receive Success, requestBody : ' + requestBody;

            response.statusCode = 200;
            response.responseBody = Blob.valueOf(JSON.serialize(responseMessage));

            status = 'SUCCESS';
            responseTime = Datetime.now();

            // JSON Keyê°’ì— currencyê°€ ì¡´ì¬í•˜ì—¬ DTO Wrapper -> Map Typeì‚¬ìš©
            Map<String, Object> jsonData = (Map<String, Object>) JSON.deserializeUntyped(requestBody);
            List<Object> results = (List<Object>) jsonData.get('results');
            for(Object result : results) {
                Map<String, Object> resultMap = (Map<String, Object>) result;
                Map<String, Object> statusMap = (Map<String, Object>) resultMap.get('status');

                String bulkId = String.valueOf(resultMap.get('bulkId'));
                String docStatus = String.valueOf(statusMap.get('groupName'));

                APIDocument__c doc = [SELECT Id, FileName__c, Status__c, AfterProcessClass__c, ExternalId__c FROM APIDocument__c WHERE Name =: bulkId];
                doc.Status__c = docStatus;
                update doc;

                // ver1.4 ëª¨ë‘ì‹¸ì¸, ì¹´ì¹´ì˜¤í†¡ í›„ì²˜ë¦¬ Process ìƒì†Class êµ¬í˜„
                if(doc.AfterProcessClass__c != null) {
                    Type type = Type.forName(doc.AfterProcessClass__c);
                    Object obj = ((CommonAfterProcess) type.newInstance()).doAfterProcess(doc.ExternalId__c);
                }
            }
        } catch(Exception e) {
            status = 'ERROR';
            responseTime = Datetime.now();

            response.responseBody = Blob.valueOf(JSON.serialize(e.getMessage()));
            response.statusCode = 500;
        } finally {
            IF_DTO.LogWrapper objLogWrapper = new IF_DTO.LogWrapper();

            objLogWrapper.requestTime = requestTime;
            objLogWrapper.requestBody = requestBody;
            objLogWrapper.status = status;
            objLogWrapper.responseTime = responseTime;
            objLogWrapper.responseBody = response.responseBody.toString();
            objLogWrapper.errorCode = String.valueOf(response.statusCode);
            objLogWrapper.logType = IF_DTO.LOG_TYPE.KAKAO_IN;

            CommonUtilCustomController.setLog(objLogWrapper);
        }
    }

    // ver1.2 ëª¨ë‘ì‹¸ì¸. ëª¨ë“ ê³ ê° ì„œëª…ì™„ë£Œì‹œ ìƒíƒœê°’ ë¶„ê¸° ì¶”ê°€
    private static String doCheckSignCustomer(String docId) {
        String status = 'ON_GOING';

        // ë¬¸ì„œì¡°íšŒ HTTP CallOut
        IF_Util ifUtil = new IF_Util(DOC_IF_ID);
        HttpResponse docResponse = ifUtil.webCallout(null, new List<String>{ docId });
        if (HttpCallOutConsts.SUCCESS_CODES.contains(docResponse.getStatusCode())) {
            String responseBody = docResponse.getBody();
            if(Test.isRunningTest()) responseBody = testJSONBody();

            Map<String, Object> docResponseMap = (Map<String, Object>) JSON.deserializeUntyped(responseBody);
            List<Object> participants = (List<Object>) docResponseMap.get('participants');
            Integer currentSigningOrder = Integer.valueOf(docResponseMap.get('currentSigningOrder'));

            /*
            Integer maxSigningOrder = 1;
            for(Object participantObj : participants) {
                Map<String, Object> participant = (Map<String, Object>) participantObj;
                Integer signingOrder = Integer.valueOf(participant.get('signingOrder'));

                maxSigningOrder = Math.max(signingOrder, maxSigningOrder);
            }
            if(maxSigningOrder == currentSigningOrder) status = 'COMPLETED(CUSTOMER)';
            */

            // ver1.5 Completed(Customer) ìƒíƒœì¡°ê±´ ë³€ê²½. ìµœì¢…ì„œëª…ì -> metadata í™•ì¸
            List<Object> metadataList = (List<Object>) docResponseMap.get('metadatas');
            List<String> numberList = new List<String>();
            for(Object obj : metadataList) {
                Map<String, Object> metadata = (Map<String, Object>) obj;

                String value = String.valueOf(metadata.get('value'));
                numberList.addAll(value.split(','));
            }

            // ver1.5 Completed(Customer) ìƒíƒœì¡°ê±´ ë³€ê²½. ìµœì¢…ì„œëª…ì -> metadata í™•ì¸
            for(Object participantObj : participants) {
                Map<String, Object> participant = (Map<String, Object>) participantObj;
                Integer signingOrder = Integer.valueOf(participant.get('signingOrder'));
                Map<String, Object> signingMethod = (Map<String, Object>) participant.get('signingMethod');

                // í˜„ì¬ ì„œëª…ìê°€ ë‚´ë¶€ ì‚¬ìš©ìì¸ê²½ìš°
                String userNumber = String.valueOf(signingMethod.get('value'));
                if (signingOrder.equals(currentSigningOrder) && numberList.contains(userNumber)) status = 'COMPLETED(CUSTOMER)';
            }
        }
        return status;
    }

    @Future(Callout = true)
    private static void asyncAfterProcess(String eventType, String docId) {
        CommonUtilController.delayTime(Datetime.now(), 5);  // 5ì´ˆ Delay
        APIDocument__c doc = [SELECT Id, Contract__c, FileName__c, Status__c, AfterProcessClass__c, ExternalId__c FROM APIDocument__c WHERE Name =: docId];
        String docStatus;
        switch on eventType {
            when 'document_started' { docStatus = 'ON_GOING'; }
            // ver1.2 ëª¨ë‘ì‹¸ì¸. ëª¨ë“ ê³ ê° ì„œëª…ì™„ë£Œì‹œ ìƒíƒœê°’ ë¶„ê¸° ì¶”ê°€
            when 'document_signed' { docStatus = doCheckSignCustomer(docId); }
            when 'document_all_signed' { docStatus = 'COMPLETED'; }
            when 'document_rejected' { docStatus = 'ABORTED'; }
            when 'document_request_canceled' { docStatus = 'ABORTED'; }
            when 'document_signing_canceled' { docStatus = 'ABORTED'; }
        }
        if('COMPLETED(CUSTOMER)'.equals(docStatus) || 'COMPLETED'.equals(docStatus)) InterfaceModuSign.doCallOutURLtoPDF(doc.Id, docStatus, true);

        // API í˜¸ì¶œì´í›„ DML
        doc.Description__c = eventType;
        doc.Status__c = docStatus;
        update doc;

        // ver1.4 ëª¨ë‘ì‹¸ì¸, ì¹´ì¹´ì˜¤í†¡ í›„ì²˜ë¦¬ Process ìƒì†Class êµ¬í˜„
        if(doc.AfterProcessClass__c != null) {
            Type type = Type.forName(doc.AfterProcessClass__c);
            Object obj = ((CommonAfterProcess) type.newInstance()).doAfterProcess(doc.ExternalId__c);
        }
    }

    private static String testJSONBody() {
        return '{' +
               '   "participants": [' +
               '    {' +
               '      "id": "c48d67a1-05e0-11f0-bd5a-77b36dabcb09",' +
               '      "type": "SIGNER",' +
               '      "name": "ì†¡ì°¬ì˜",' +
               '      "signingOrder": 1,' +
               '      "signingDue": {' +
               '        "valid": true,' +
               '        "datetime": "2025-04-03T23:12:18.794Z"' +
               '      },' +
               '      "signingMethod": {' +
               '        "type": "EMAIL",' +
               '        "value": "payo03@solomontech.net"' +
               '      },' +
               '      "locale": "ko",' +
               '      "verification": null' +
               '    }' +
               '  ],' +
               '  "currentSigningOrder": 1,' +
               '  "metadatas" : [' +
               '    {' +
               '      "key" : "internal", ' +
               '      "value" : "010" ' +
               '    }' +
               '  ]' +
               '}';
    }
}
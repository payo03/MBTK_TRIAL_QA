/**
* @Author            : payo03@solomontech.net
* @Description 		 : 
* @Target            : 
* @Modification Log
  Ver      Date            Author                           Modification
  ===================================================================================
  1.0      2024-12-19      payo03@solomontech.net           Created
  1.1      2024-12-26      payo03@solomontech.net           Webhook Î∂ÑÍ∏∞Ï≤òÎ¶¨
  1.2      2025-02-05      payo03@solomontech.net           Î™®ÎëêÏã∏Ïù∏. Î™®Îì†Í≥†Í∞ù ÏÑúÎ™ÖÏôÑÎ£åÏãú ÏÉÅÌÉúÍ∞í Î∂ÑÍ∏∞ Ï∂îÍ∞Ä
  1.3      2025-02-26      payo03@solomontech.net           Î™®ÎëêÏã∏Ïù∏. ÌõÑÏ≤òÎ¶¨ Process ÎπÑÎèôÍ∏∞Î°ú Ïã§Ìñâ
  1.4      2025-04-17      payo03@solomontech.net           Î™®ÎëêÏã∏Ïù∏ ÌõÑÏ≤òÎ¶¨ Process ÏÉÅÏÜçClass Íµ¨ÌòÑ
*/
@RestResource(UrlMapping='/api/webhook/*')
global without sharing class IF_Webhook {

    global final static String LABEL_AUTHCODE = Label.ModuSignAuthcode;
    global final static String DOC_IF_ID = 'MDSIGN_006';

    @HttpPost
    global static void doPost() {
        // ver1.1 Webhook Î∂ÑÍ∏∞Ï≤òÎ¶¨
        String pathCase = RestContext.request.requestURI.substringAfter('/api/webhook/');
        System.debug(pathCase);
        switch on pathCase {
            // Î™®ÎëêÏã∏Ïù∏ WebHook
            when 'modusign' { moduSignWebhook(); }
            // Ïπ¥Ïπ¥Ïò§ÌÜ° WebHook
            when 'kakao' { kakaoWebhook(); }
        }
    }

    private static void moduSignWebhook() {
        String status;
        Datetime responseTime;
        Datetime requestTime = Datetime.now();

        String authcode;
        RestRequest request = RestContext.request;
        RestResponse response = RestContext.response;

        String requestBody = request.requestBody.toString();
        System.debug(requestBody);
        response.addHeader('Content-Type', 'application/json');
        try {
            /*
                https://developers.modusign.co.kr/docs/webhook-event
                üìò ÏïÑÎûòÏôÄ Í∞ôÏùÄ ÏÉÅÌô©ÏóêÏÑú WebhookÏùÄ Ìò∏Ï∂ú Ïã§Ìå®Î°ú ÌåêÎã®ÌïòÍ≥† ÏµúÎåÄ 5Ìöå Ïû¨ÏãúÎèÑ Ìï©ÎãàÎã§.

                    Webhook event ÏàòÏã† Ïãú 200Î≤àÎåÄ ÏùëÎãµÏù¥ ÏïÑÎãê Í≤ΩÏö∞ Ïû¨ÏãúÎèÑÌï©ÎãàÎã§.
                    ÏùëÎãµÏùÑ(200Î≤àÎåÄ ÏùëÎãµ) Î®ºÏ†Ä ÌöåÏã† ÌõÑ ÎÇ¥Î∂Ä ÏûëÏóÖÏùÑ ÏßÑÌñâÌï¥Ï£ºÏãúÎäî Í≤ÉÏùÑ Í∂åÏû• ÎìúÎ¶ΩÎãàÎã§.

                    üìå Îã§ÏùåÏùò Í≤ΩÏö∞ Webhook ÏöîÏ≤≠ Ïã§Ìå®Î°ú Í∞ÑÏ£ºÌï©ÎãàÎã§.
                        - 2xx ÏùëÎãµÏù¥ ÏïÑÎãåÍ≤ΩÏö∞
                        - ÏùëÎãµÏóê 10Ï¥à Ïù¥ÏÉÅ ÏÜåÏöîÎêòÎäî Í≤ΩÏö∞(timeout)
                    üìå ÏöîÏ≤≠ Ïã§Ìå®Î°ú Í∞ÑÏ£ºÎêú Í≤ΩÏö∞, Ïã§Ìå® Ï≤òÎ¶¨ Ï†ïÏ±ÖÏóê Îî∞Îùº, Webhook ÏµúÎåÄ 5Ìöå ÏöîÏ≤≠Ïù¥ Îê† Ïàò ÏûàÏäµÎãàÎã§.

                    ‚ùóÔ∏èÏ†ïÏÉÅ Ï≤òÎ¶¨Í∞Ä ÎêòÏóàÏùåÏóêÎèÑ 2xxÎ°ú ÏùëÎãµÌïòÏßÄ ÏïäÎäî Í≤ΩÏö∞, WebhookÏù¥ Ïû¨Ï†ÑÏÜ°ÎêòÎ©∞ Ï§ëÎ≥µÏúºÎ°ú Ï≤òÎ¶¨ Îê† Ïàò ÏûàÏäµÎãàÎã§.
                    ‚ùóÔ∏èÔ∏èÏù¥Ï†ê ÏñëÏßÄÌïòÏÖîÏÑú Ïò¨Î∞îÎ•∏ ÏùëÎãµÏùÑ ÌöåÏã†Ìïú ÌõÑ Îã§Ïùå ÏûëÏóÖÏùÑ ÏàòÌñâÌïòÎèÑÎ°ù Íµ¨ÌòÑÌïòÏãúÎäî Í≤ÉÏùÑ Í∂åÏû•Ìï¥ ÎìúÎ¶ΩÎãàÎã§.

                    üìå ÏïÑÎûòÏùò Í≤ΩÏö∞Îäî Ïû¨ÏãúÎèÑ ÌñàÏùÑ Îïå ÏÑ±Í≥µ Ï†ÑÌôúÏú®Ïù¥ ÎÇÆÍ±∞ÎÇò, ÏùòÎèÑÌïòÏßÄ ÏïäÏùÄ Ï§ëÎ≥µ ÏûëÏóÖÏùÑ Î∞úÏÉùÏãúÌÇ¨ Í∞ÄÎä•ÏÑ± ÏûàÏúºÎØÄÎ°ú Ïû¨ÏãúÎèÑ ÌïòÏßÄ ÏïäÏäµÎãàÎã§.
                        - 401, 404 ÏùëÎãµÏùÑ Î∞òÌôòÌôò Í≤ΩÏö∞
                        - ÏùëÎãµÏóê 10Ï¥à Ïù¥ÏÉÅÏù¥ ÏÜåÏöîÎêòÎäî Í≤ΩÏö∞(timeout)
             */
            for(String key : request.headers.keySet()) {
                if('AUTHCODE'.equals(key.toUpperCase())) authcode = request.headers.get(key);
            }
            if(authcode == null || !('Bearer ' + LABEL_AUTHCODE).equals(authcode)) throw new IllegalArgumentException('Invalid Authcode: ' + authcode);

            IF_DTO.ModuSign moduSign = (IF_DTO.ModuSign) JSON.deserialize(requestBody, IF_DTO.ModuSign.class);
            String eventType = moduSign.event.type;
            String documentId = moduSign.document.id;
            String responseMessage = 'Webhook Receive Success. Event Type: ' + eventType;

            response.responseBody = Blob.valueOf(JSON.serialize(responseMessage));
            response.statusCode = 200;
            status = 'SUCCESS';
            responseTime = Datetime.now();

            // ver1.3 Î™®ÎëêÏã∏Ïù∏. ÌõÑÏ≤òÎ¶¨ Process ÎπÑÎèôÍ∏∞Î°ú Ïã§Ìñâ
            asyncAfterProcess(eventType, documentId);
        } catch(IllegalArgumentException e) {
            status = 'ERROR';
            responseTime = Datetime.now();

            response.responseBody = Blob.valueOf(JSON.serialize(e.getMessage()));
            response.statusCode = 401;
        } catch(Exception e) {
            status = 'ERROR';
            responseTime = Datetime.now();

            response.responseBody = Blob.valueOf(JSON.serialize(e.getMessage()));
            response.statusCode = 500;
        } finally {
            IF_DTO.LogWrapper objLogWrapper = new IF_DTO.LogWrapper();

            objLogWrapper.requestTime = requestTime;
            objLogWrapper.requestBody = requestBody;
            objLogWrapper.status = status;
            objLogWrapper.responseTime = responseTime;
            objLogWrapper.responseBody = response.responseBody.toString();
            objLogWrapper.errorCode = String.valueOf(response.statusCode);
            objLogWrapper.logType = IF_DTO.LOG_TYPE.MODUSIGN_IN;

            CommonUtilCustomController.setLog(objLogWrapper);
        }
    }

    private static void kakaoWebhook() {
        String status;
        Datetime responseTime;
        Datetime requestTime = Datetime.now();

        RestRequest request = RestContext.request;
        RestResponse response = RestContext.response;

        response.addHeader('Content-Type', 'application/json');
        String requestBody = request.requestBody.toString();
        try {
            String responseMessage = 'Webhook Receive Success, requestBody : ' + requestBody;

            response.statusCode = 200;
            response.responseBody = Blob.valueOf(JSON.serialize(responseMessage));

            status = 'SUCCESS';
            responseTime = Datetime.now();

            // JSON KeyÍ∞íÏóê currencyÍ∞Ä Ï°¥Ïû¨ÌïòÏó¨ DTO Wrapper -> Map TypeÏÇ¨Ïö©
            Map<String, Object> jsonData = (Map<String, Object>) JSON.deserializeUntyped(requestBody);
            List<Object> results = (List<Object>) jsonData.get('results');
            for(Object result : results) {
                Map<String, Object> resultMap = (Map<String, Object>) result;
                Map<String, Object> statusMap = (Map<String, Object>) resultMap.get('status');

                String bulkId = String.valueOf(resultMap.get('bulkId'));
                String docStatus = String.valueOf(statusMap.get('groupName'));

                APIDocument__c doc = [SELECT Id, FileName__c, Status__c FROM APIDocument__c WHERE Name =: bulkId];
                doc.Status__c = docStatus;

                update doc;
            }
        } catch(Exception e) {
            status = 'ERROR';
            responseTime = Datetime.now();

            response.responseBody = Blob.valueOf(JSON.serialize(e.getMessage()));
            response.statusCode = 500;
        } finally {
            IF_DTO.LogWrapper objLogWrapper = new IF_DTO.LogWrapper();

            objLogWrapper.requestTime = requestTime;
            objLogWrapper.requestBody = requestBody;
            objLogWrapper.status = status;
            objLogWrapper.responseTime = responseTime;
            objLogWrapper.responseBody = response.responseBody.toString();
            objLogWrapper.errorCode = String.valueOf(response.statusCode);
            objLogWrapper.logType = IF_DTO.LOG_TYPE.KAKAO_IN;

            CommonUtilCustomController.setLog(objLogWrapper);
        }
    }

    // ver1.2 Î™®ÎëêÏã∏Ïù∏. Î™®Îì†Í≥†Í∞ù ÏÑúÎ™ÖÏôÑÎ£åÏãú ÏÉÅÌÉúÍ∞í Î∂ÑÍ∏∞ Ï∂îÍ∞Ä
    private static String doCheckSignCustomer(String docId) {
        String status = 'ON_GOING';

        // Î¨∏ÏÑúÏ°∞Ìöå HTTP CallOut
        IF_Util ifUtil = new IF_Util(DOC_IF_ID);
        HttpResponse docResponse = ifUtil.webCallout(null, new List<String>{ docId });
        if (HttpCallOutConsts.SUCCESS_CODES.contains(docResponse.getStatusCode())) {
            String responseBody = docResponse.getBody();
            if(Test.isRunningTest()) responseBody = testJSONBody();

            Map<String, Object> docResponseMap = (Map<String, Object>) JSON.deserializeUntyped(responseBody);
            List<Object> participants = (List<Object>) docResponseMap.get('participants');
            Integer currentSigningOrder = Integer.valueOf(docResponseMap.get('currentSigningOrder'));

            Integer maxSigningOrder = 1;
            for(Object participantObj : participants) {
                Map<String, Object> participant = (Map<String, Object>) participantObj;
                Integer signingOrder = Integer.valueOf(participant.get('signingOrder'));

                maxSigningOrder = Math.max(signingOrder, maxSigningOrder);
            }
            if(maxSigningOrder == currentSigningOrder) status = 'COMPLETED(CUSTOMER)';
        }
        return status;
    }

    @Future(Callout = true)
    private static void asyncAfterProcess(String eventType, String docId) {
        CommonUtilController.delayTime(Datetime.now(), 5);  // 5Ï¥à Delay
        APIDocument__c doc = [SELECT Id, Contract__c, FileName__c, Status__c, AfterProcessClass__c FROM APIDocument__c WHERE Name =: docId];
        String docStatus;
        switch on eventType {
            when 'document_started' { docStatus = 'ON_GOING'; }
            // ver1.2 Î™®ÎëêÏã∏Ïù∏. Î™®Îì†Í≥†Í∞ù ÏÑúÎ™ÖÏôÑÎ£åÏãú ÏÉÅÌÉúÍ∞í Î∂ÑÍ∏∞ Ï∂îÍ∞Ä
            when 'document_signed' { docStatus = doCheckSignCustomer(docId); }
            when 'document_all_signed' { docStatus = 'COMPLETED'; }
            when 'document_rejected' { docStatus = 'ABORTED'; }
            when 'document_request_canceled' { docStatus = 'ABORTED'; }
            when 'document_signing_canceled' { docStatus = 'ABORTED'; }
        }
        if('COMPLETED(CUSTOMER)'.equals(docStatus) || 'COMPLETED'.equals(docStatus)) InterfaceModuSign.doCallOutURLtoPDF(doc.Id, docStatus, true);

        // API Ìò∏Ï∂úÏù¥ÌõÑ DML
        doc.Description__c = eventType;
        doc.Status__c = docStatus;
        update doc;

        if(doc.AfterProcessClass__c != null) {
            Type type = Type.forName(doc.AfterProcessClass__c);
            // Í≥ÑÏïΩ Î∞è ÏûÖÍ∏àÏôÑÎ£å ÌôïÏù∏
            if('COMPLETED(CUSTOMER)'.equals(docStatus)) ((CommonAfterProcess) type.newInstance()).doAfterProcess(doc.Contract__c);
        }
    }

    private static String testJSONBody() {
        return '{' +
               '   "participants": [' +
               '    {' +
               '      "id": "c48d67a1-05e0-11f0-bd5a-77b36dabcb09",' +
               '      "type": "SIGNER",' +
               '      "name": "ÏÜ°Ï∞¨ÏòÅ",' +
               '      "signingOrder": 1,' +
               '      "signingDue": {' +
               '        "valid": true,' +
               '        "datetime": "2025-04-03T23:12:18.794Z"' +
               '      },' +
               '      "signingMethod": {' +
               '        "type": "EMAIL",' +
               '        "value": "payo03@solomontech.net"' +
               '      },' +
               '      "locale": "ko",' +
               '      "verification": null' +
               '    }' +
               '  ],' +
               '  "currentSigningOrder": 1' +
               '}';
    }
}